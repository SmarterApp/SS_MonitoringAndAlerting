/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.monitoringalerting.service;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.beanutils.BeanUtils;
import org.junit.Test;
import org.opentestsystem.shared.monitoringalerting.AbstractPersistenceEmbeddedTest;
import org.opentestsystem.shared.monitoringalerting.domain.Log;
import org.opentestsystem.shared.monitoringalerting.domain.MAException;
import org.opentestsystem.shared.monitoringalerting.domain.search.LogSearchRequest;
import org.opentestsystem.shared.monitoringalerting.gateway.LogService;
import org.opentestsystem.shared.search.domain.SearchFilter;
import org.opentestsystem.shared.search.domain.SearchFilter.SearchDataType;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;

@SuppressWarnings({ "PMD.AvoidInstantiatingObjectsInLoops", "PMD.AvoidCatchingGenericException" })
public class LogServiceTest extends AbstractPersistenceEmbeddedTest {

    private static final String COOL = "cool";
    private static final String PAGE_SIZE = "pageSize";
    private static final String CUR_PAGE = "currentPage";
    private static final String SORT_DIR = "sortDir";
    private static final String ASC = "asc";
    private static final String SORT_KEY = "sortKey";
    private static final String SERVER = "server";
    private static final String ALTKEY_NODE = "alternateKey.node";
    private static final String PREVIOUS_FIRST_ID = "previousFirstId";

    @Autowired
    private LogService logService;

    @Test
    public void testStringFilters() throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {
        final List<SearchFilter> keys = new LogSearchRequest(new HashMap<String, String[]>()).getSearchFilters();

        for (final SearchFilter filter : keys) {
            if (filter.getDataType().equals(SearchDataType.String)) {
                createLogs(10, filter.getSearchApiName(), COOL);
                createLogs(10, filter.getSearchApiName(), "bogus");

                final Map<String, String[]> requestMap = new HashMap<String, String[]>();
                requestMap.put(PAGE_SIZE, new String[] { "100" });
                requestMap.put(CUR_PAGE, new String[] { "0" });
                requestMap.put(SORT_DIR, new String[] { ASC });
                requestMap.put(SORT_KEY, new String[] { SERVER });
                requestMap.put(filter.getSearchApiName(), new String[] { COOL });

                final LogSearchRequest searchRequest = new LogSearchRequest(requestMap);

                final SearchResponse<Log> response = this.logService.searchLogs(searchRequest);

                assertThat(response.getReturnCount(), is(10));
                assertThat(response.getSearchResults().size(), is(10));
                for (final Log result : response.getSearchResults()) {
                    assertThat(BeanUtils.getProperty(result, filter.getSearchApiName()), is(COOL));
                }
            }
        }
    }

    @Test
    public void testMultipleFilters() {
        final Map<String, Object> params = new HashMap<String, Object>();
        params.put(ALTKEY_NODE, COOL);
        params.put("alternateKey.server", "serverA");

        final Map<String, Object> params2 = new HashMap<String, Object>();
        params2.put(ALTKEY_NODE, "uncool");
        params2.put("alternateKey.server", "serverB");

        final Map<String, Object> params3 = new HashMap<String, Object>();
        params3.put(ALTKEY_NODE, COOL);
        params3.put("alternateKey.server", "serverC");

        createLogs(10, params);
        createLogs(10, params2);
        createLogs(10, params3);

        final Map<String, String[]> requestMap = new HashMap<String, String[]>();
        requestMap.put(PAGE_SIZE, new String[] { "100" });
        requestMap.put(CUR_PAGE, new String[] { "0" });
        requestMap.put(SORT_DIR, new String[] { ASC });
        requestMap.put(SORT_KEY, new String[] { SERVER });
        requestMap.put("node", new String[] { COOL });
        requestMap.put(SERVER, new String[] { "serverc" });

        LogSearchRequest searchRequest = new LogSearchRequest(requestMap);

        SearchResponse<Log> response = this.logService.searchLogs(searchRequest);

        assertThat(response.getReturnCount(), is(10));
        assertThat(response.getSearchResults().size(), is(10));
        for (final Log result : response.getSearchResults()) {
            assertThat(result.getNode(), is(COOL));
            assertThat(result.getServer(), is("serverc"));
        }

        requestMap.remove(SERVER);
        searchRequest = new LogSearchRequest(requestMap);
        response = this.logService.searchLogs(searchRequest);

        assertThat(response.getReturnCount(), is(20));
        assertThat(response.getSearchResults().size(), is(20));
        for (final Log result : response.getSearchResults()) {
            assertThat(result.getNode(), is(COOL));
        }

        requestMap.put("node", new String[] { COOL });
        requestMap.put(SERVER, new String[] { "serverb" });
        searchRequest = new LogSearchRequest(requestMap);
        response = this.logService.searchLogs(searchRequest);

        assertThat(response.getReturnCount(), is(0));
        assertThat(response.getSearchResults().size(), is(0));
    }

    @Test
    public void testPagingFeatures() {
        final HashMap<String, Log> page1Map = new HashMap<String, Log>();
        final HashMap<String, Log> page2Map = new HashMap<String, Log>();
        final HashMap<String, Log> page3Map = new HashMap<String, Log>();
        final HashMap<String, Log> page4Map = new HashMap<String, Log>();

        createLogs(10, ALTKEY_NODE, COOL);
        createLogs(10, ALTKEY_NODE, "uncool");

        final Map<String, String[]> requestMap = new HashMap<String, String[]>();
        requestMap.put(PAGE_SIZE, new String[] { "3" });
        requestMap.put(CUR_PAGE, new String[] { "0" });
        requestMap.put(SORT_DIR, new String[] { "desc", ASC });
        requestMap.put(SORT_KEY, new String[] { "_id", SERVER });
        requestMap.put("node", new String[] { COOL });

        LogSearchRequest searchRequest = new LogSearchRequest(requestMap);
        String firstResultId = null, lastResultId = null;

        SearchResponse<Log> response = this.logService.searchLogs(searchRequest);

        assertThat(response.getReturnCount(), is(3));
        assertThat(response.getSearchResults().size(), is(3));

        for (final Log result : response.getSearchResults()) {
            page1Map.put(result.getId(), result);
            if (lastResultId == null) {
                lastResultId = result.getId();
            }
            firstResultId = result.getId();
        }

        requestMap.put(PREVIOUS_FIRST_ID, new String[] { firstResultId });
        searchRequest = new LogSearchRequest(requestMap);
        response = this.logService.searchLogs(searchRequest);
        assertThat(response.getReturnCount(), is(3));
        assertThat(response.getSearchResults().size(), is(3));

        for (final Log result : response.getSearchResults()) {
            page2Map.put(result.getId(), result);
            if (lastResultId == null) {
                lastResultId = result.getId();
            }
            firstResultId = result.getId();
        }

        requestMap.put(PREVIOUS_FIRST_ID, new String[] { firstResultId });
        searchRequest = new LogSearchRequest(requestMap);
        response = this.logService.searchLogs(searchRequest);
        assertThat(response.getReturnCount(), is(3));
        assertThat(response.getSearchResults().size(), is(3));

        for (final Log result : response.getSearchResults()) {
            page3Map.put(result.getId(), result);
            if (lastResultId == null) {
                lastResultId = result.getId();
            }
            firstResultId = result.getId();
        }

        requestMap.put(PREVIOUS_FIRST_ID, new String[] { firstResultId });
        firstResultId = null;
        searchRequest = new LogSearchRequest(requestMap);
        response = this.logService.searchLogs(searchRequest);
        assertThat(response.getReturnCount(), is(1));
        assertThat(response.getSearchResults().size(), is(1));

        for (final Log result : response.getSearchResults()) {
            page4Map.put(result.getId(), result);
            if (lastResultId == null) {
                lastResultId = result.getId();
            }
            firstResultId = result.getId();
        }

        requestMap.put(PREVIOUS_FIRST_ID, new String[] { firstResultId });
        firstResultId = null;
        searchRequest = new LogSearchRequest(requestMap);
        response = this.logService.searchLogs(searchRequest);
        assertThat(response.getReturnCount(), is(0));
        assertThat(response.getSearchResults().size(), is(0));

        requestMap.put(CUR_PAGE, new String[] { "90000" });
        searchRequest = new LogSearchRequest(requestMap);
        response = this.logService.searchLogs(searchRequest);
        assertThat(response.getReturnCount(), is(0));
        assertThat(response.getSearchResults().size(), is(0));

        final HashMap<String, Log> allLogs = new HashMap<String, Log>();
        allLogs.putAll(page1Map);
        allLogs.putAll(page2Map);
        allLogs.putAll(page3Map);
        allLogs.putAll(page4Map);
        assertThat(allLogs.size(), is(10));
    }

    @Test
    public void testNoFilter() {
        createLogs(10, ALTKEY_NODE, COOL);
        createLogs(10, ALTKEY_NODE, "uncool");

        final Map<String, String[]> requestMap = new HashMap<String, String[]>();
        requestMap.put(PAGE_SIZE, new String[] { "100" });
        requestMap.put(CUR_PAGE, new String[] { "0" });
        requestMap.put(SORT_DIR, new String[] { ASC });
        requestMap.put(SORT_KEY, new String[] { SERVER });

        final LogSearchRequest searchRequest = new LogSearchRequest(requestMap);

        final SearchResponse<Log> response = this.logService.searchLogs(searchRequest);

        assertThat(response.getReturnCount(), is(20));
        assertThat(response.getSearchResults().size(), is(20));
    }

    private List<Log> createLogs(final int count, final String property, final String value) {
        final List<Log> logs = new ArrayList<Log>(count);
        for (int i = 0; i < count; i++) {
            final Log log = FACTORY.manufacturePojo(Log.class);
            log.setId(null);
            try {
                BeanUtils.setProperty(log, property, value);
            } catch (final Exception e) {
                throw new MAException("error with data setup.", e);
            }
            this.logService.addLog(log);
        }
        return logs;
    }

    private List<Log> createLogs(final int count, final Map<String, Object> values) {
        final List<Log> logs = new ArrayList<Log>(count);
        for (int i = 0; i < count; i++) {
            final Log log = FACTORY.manufacturePojo(Log.class);
            log.setId(null);
            try {
                for (final Entry<String, Object> entry : values.entrySet()) {
                    BeanUtils.setProperty(log, entry.getKey(), entry.getValue());
                }
            } catch (final Exception e) {
                throw new MAException("error with data setup.", e);
            }
            this.logService.addLog(log);
        }
        return logs;
    }

}
