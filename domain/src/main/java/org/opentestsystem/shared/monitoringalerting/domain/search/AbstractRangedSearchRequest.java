/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.monitoringalerting.domain.search;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.bson.types.ObjectId;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchFilter;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;

import com.google.common.collect.Maps;

/**
 * This is a psuedo-domain object, not really existing in the persistent store,
 * but instead is used as part of the Gateway interface for convey complex
 * search criteria. Note: this scopes the regular paged queries by a custom range field.
 */
public abstract class AbstractRangedSearchRequest extends AbstractSearchRequest implements Serializable {

    private static final long serialVersionUID = 1853144907289436990L;
    private static final String ID_KEY = "_id";
    private static final String PREVIOUS_FIRST_ID = "previousFirstId";

    private final Map<String, String[]> additionalSearchCriteria = Maps.newHashMap();

    public AbstractRangedSearchRequest(final Map<String, String[]> requestMap) {
        super(requestMap);
        if (requestMap.get(PREVIOUS_FIRST_ID) != null) {
            this.additionalSearchCriteria.put(PREVIOUS_FIRST_ID, requestMap.get(PREVIOUS_FIRST_ID));
        }
    }

    @Override
    protected abstract List<SearchFilter> getSearchFilters();

    @Override
    protected abstract String getSearchResource();

    @Override
    public Query buildQuery() {
        final Map<String, Criteria> criteriaMap = super.buildCriteria();
        return composeQuery(criteriaMap.values());
    }

    public Query buildTotalCountQuery() {
        final Map<String, Criteria> criteriaMap = super.buildCriteria();
        return composeTotalCountQuery(criteriaMap.values());
    }
    
    @Override
    protected Query composeQuery(final Collection<Criteria> inCriteria) {
        final Query query = new Query();
        for (final Criteria cri : inCriteria) {
            query.addCriteria(cri);
        }

        final List<Order> orders = new ArrayList<Order>();
        // for ranged searches, ID descending must be foremost sort param
        final Order idOrder = new Order(Direction.DESC, ID_KEY);
        orders.add(idOrder);
        if (super.getSortKeys() != null) {
            for (int i = 0; i < super.getSortKeys().length; i++) {
                Direction sortDir = null;
                final String key = super.getSortKeys()[i];
                if (!StringUtils.equals(key, ID_KEY)) {
                    if (super.getSortDirections().length >= i + 1) {
                        sortDir = super.getSortDirections()[i];
                    }
                    final Order order = new Order(sortDir, key);
                    orders.add(order);
                }
            }
        }
        final Sort sort = new Sort(orders);

        query.with(sort);
        query.limit(super.getPageSize());
        // skip deliberately avoided in favor of below ID range

        if (this.additionalSearchCriteria.containsKey(PREVIOUS_FIRST_ID)) {
            final String previousFirstId = this.additionalSearchCriteria.get(PREVIOUS_FIRST_ID)[0];
            query.addCriteria(Criteria.where(ID_KEY).lt(new ObjectId(previousFirstId)));
        }

        return query;
    }
    
    protected Query composeTotalCountQuery(final Collection<Criteria> inCriteria) {
        final Query query = new Query();
        for (final Criteria cri : inCriteria) {
            query.addCriteria(cri);
        }
    	return query;
    }

    public Map<String, String[]> getAdditionalSearchCriteria() {
        return this.additionalSearchCriteria;
    }
}
